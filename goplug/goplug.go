package goplug

import (
	"encoding/json"
	"errors"
	"fmt"
	"io/fs"
	"io/ioutil"
	"log"
	"net/rpc"
	"net/rpc/jsonrpc"
	"os"
	"os/exec"
	"path"
	"sync"

	"github.com/aligator/checkpoint"
	"github.com/aligator/goplug/common"
	"github.com/aligator/goplug/errutil"
)

// PluginType defines the type of plugin.
// All possible values are defined as const in this package.
type PluginType string

var (
	ErrPluginDoesNotExist = errors.New("plugin does not exist")
	ErrCallingPlugin      = errors.New("could not call the plugin")
)

const (
	// OneShot is a plugin which gets called when a specific event happens.
	// This can be for example a subcommand in command line tools.
	// This type of plugin can query information from the host. And does only
	// run when needed.
	OneShot = PluginType("one_shot")

	// DataSource is a plugin which provides data from any datasource.
	// This type of plugin gets queried by the host and runs in the background
	// as long as the host needs it.
	DataSource = PluginType("data_source")
)

// PluginInfo contains all basic information about a plugin.
type PluginInfo struct {
	// ID should be unique across all plugins.
	// It is good practice to use a domain, email or github repo
	// which belongs to you.
	//  e.g.
	//  * github.com/aligator/superplugin
	//  * my@email.com/superplugin
	//  * superplugin.aligator.dev
	ID string `json:"id"`

	PluginType PluginType `json:"plugin_type"`

	// Metadata is a field which can be used by the host to allow custom
	// plugin information. It is subject to the host to provide ways for the
	// plugin to read and set it properly.
	// It may be in any text form (such as json) and is just
	// sent as a normal string.
	Metadata string `json:"metadata"`
}

// plugin is the internal representation of a plugin.
type plugin struct {
	PluginInfo
	filePath string
}

// GoPlug is the main struct used to initialize and load plugins.
// Example setup:
//  g := goplug.GoPlug{
//		PluginFolder: "./example/plugin-bin",
//		Host:         h,
//		Actions: &plug.HostActions{
//			Actions0AppRef: &app,
//		},
//	}
type GoPlug struct {
	// PluginFolder defines where plugins can be found.
	PluginFolder string

	// Host is the part of GoPlug which has to be implemented
	// by the host application.
	Host Host

	// Actions has to be set to a pointer of the struct which
	// has all jsongrpc-valid methods.
	// Normally this is the HostActions struct generated by
	// the goplug generator.
	// Example:
	//  Actions: &plug.HostActions{
	//		Actions0AppRef: &app,
	//	},
	Actions interface{}

	// plugins contains a list of all potential plugin
	// executables found in the plugin folder.
	// Note: they are not yet initialized, so they may
	// not be valid plugins.
	plugins []plugin

	// oneShotPlugins contains all plugins which registered themselves as
	// oneShot plugins.
	// When in the initialization phase, use the oneShotPluginsMutex to
	// lock it.
	// After initialization phase do not write to the map anymore.
	oneShotPlugins map[string]*plugin

	// oneShotPluginsMutex is a mutex which locks the
	// oneShotPlugins map while in the initialization phase
	// to prevent concurrent writes to it.
	oneShotPluginsMutex sync.Mutex
}

// Checks if the plugin is a valid executable.
// These checks are done without executing it.
func isValidPlugin(info fs.FileInfo) bool {
	if info.IsDir() {
		return false
	}

	if info.Name() == ".gitkeep" {
		return false
	}

	// ToDo: implement checks
	//       Maybe invent a custom filename rule, such as
	//       "***.plugin" ("***.plugin.exe" on windows).
	//       This could be made configurable...
	return true
}

// Init initializes and starts all plugins.
// It blocks until all plugins are initialized.
func (g *GoPlug) Init() error {
	entries, err := ioutil.ReadDir(g.PluginFolder)
	if err != nil {
		return err
	}

	g.oneShotPluginsMutex.Lock()
	g.oneShotPlugins = make(map[string]*plugin)
	g.oneShotPluginsMutex.Unlock()

	errCh := make(chan error)
	allErrorsCh := errutil.Collect(errCh)

	wg := sync.WaitGroup{}
	wg.Add(len(entries))
	// Initialize all found plugin binaries.
	for i := range entries {
		entry := entries[i]
		go func() {
			defer wg.Done()

			if !isValidPlugin(entry) {
				return
			}

			// Start the plugin with the -init flag.
			// The plugin should return some information about it.
			filePath := path.Join(g.PluginFolder, entry.Name())

			p := plugin{
				filePath: filePath,
			}

			// Call the plugin with -init which should return the
			// plugin information as json to stdout.
			cmd := exec.Command(filePath, "-init")
			// Connect stderr to be able to get errors and panics
			// from the plugin.
			cmd.Stderr = os.Stderr
			res, err := cmd.Output()
			if err != nil {
				errCh <- checkpoint.From(err)
				return
			}

			err = json.Unmarshal(res, &p.PluginInfo)
			if err != nil {
				errCh <- checkpoint.From(err)
				return
			}

			if p.PluginType != OneShot {
				log.Println(p.ID, "- currently only one_shot plugins are supported")
				return
			}

			// Register the plugin as OneShot.
			g.oneShotPluginsMutex.Lock()
			g.oneShotPlugins[p.ID] = &p
			g.oneShotPluginsMutex.Unlock()

			// Call the implementation from the host.
			// The callback should be called when the plugin gets called.
			// All arguments it should run with are passed by the slice.
			err = g.Host.RegisterOneShot(p.PluginInfo, func(args []string) error {
				// Actually start the plugin in onShot mode.
				return g.oneShot(p.ID, args)
			})
			if err != nil {
				errCh <- checkpoint.From(err)
				return
			}
		}()
	}

	wg.Wait()
	close(errCh)

	err, _ = <-allErrorsCh
	return err
}

// oneShot starts the plugin as oneShot plugin with the given arguments.
func (g *GoPlug) oneShot(ID string, args []string) error {
	if p, ok := g.oneShotPlugins[ID]; !ok {
		return checkpoint.From(fmt.Errorf("PluginID: %v: %w", ID, ErrPluginDoesNotExist))
	} else {
		// Start rpc.
		cmd := exec.Command(p.filePath, args...)

		// Connect stdin and stdout
		outPipe, err := cmd.StdoutPipe()
		if err != nil {
			return checkpoint.Wrap(fmt.Errorf("PluginID: %v: %w", ID, err), ErrCallingPlugin)
		}

		inPipe, err := cmd.StdinPipe()
		if err != nil {
			return checkpoint.Wrap(fmt.Errorf("PluginID: %v: %w", ID, err), ErrCallingPlugin)
		}

		// Connect stderr directly to the host stderr to
		// still allow to receive panics and errors of the plugin.
		cmd.Stderr = os.Stderr

		// Use a CombinedReadWriter which combines the two pipes.
		codec := jsonrpc.NewServerCodec(common.CombinedReadWriter{
			In:  outPipe,
			Out: inPipe,
		})

		s := rpc.NewServer()

		// Register the host specific actions.
		err = s.RegisterName("Host", g.Actions)
		if err != nil {
			return checkpoint.Wrap(fmt.Errorf("PluginID: %v: %w", ID, err), ErrCallingPlugin)
		}

		// Register actions available to all plugins.
		err = s.RegisterName("HostControl", &HostControl{})
		if err != nil {
			return checkpoint.Wrap(fmt.Errorf("PluginID: %v: %w", ID, err), ErrCallingPlugin)
		}

		// Start the jsonrpc server.
		go func() {
			s.ServeCodec(codec)
		}()

		// Start the plugin.
		err = cmd.Run()
		if err != nil {
			return err
		}

		return nil
	}
}
